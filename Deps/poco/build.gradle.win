import com.ullink.NuGetSpec;
import com.ullink.NuGetPack;
import com.ullink.NuGetPush;

buildscript {
}

plugins {
	id 'com.ullink.nuget' version '2.15'
//	id 'net.saliman.cobertura' version '2.5.1'
//	id 'com.jfrog.artifactory' version '4.1'
}
apply plugin: 	'base' 
apply plugin: 	'nuget'
nuget {
	version = '4.4.1'
}


def os = org.gradle.internal.os.OperatingSystem.current()
def String version = file("VERSION").text.replaceAll("[\n\r]", "")

File appendDebugSuffix(File binaryFile) {
	String name = binaryFile.getName()
	File parent = binaryFile.getParentFile()
	int extensionSeparator = name.lastIndexOf('.')
	if (extensionSeparator == -1) {
		return new File(parent, name + "d")
	}
	return new File(parent, name.substring(0, extensionSeparator) + "d" + name.substring(extensionSeparator))
}
 
File appendStaticSuffix(File binaryFile) {
    def os = org.gradle.internal.os.OperatingSystem.current()
	if (!os.windows) {
		return binaryFile
    }
    String name = binaryFile.getName()
    File parent = binaryFile.getParentFile()
    int extensionSeparator = name.lastIndexOf('.')
    if (extensionSeparator == -1) {
    	return new File(parent, name + "MT")
    }
    return new File(parent, name.substring(0, extensionSeparator) + "MT" + name.substring(extensionSeparator))
}
File appendSemiStaticSuffix(File binaryFile) {
	String name = binaryFile.getName()
	File parent = binaryFile.getParentFile()
	int extensionSeparator = name.lastIndexOf('.')
	if (extensionSeparator == -1) {
		return new File(parent, name + "MD")
	}
	return new File(parent, name.substring(0, extensionSeparator) + "MD" + name.substring(extensionSeparator))
}
File prefixByPoco(File binaryFile) {
	String name = binaryFile.getName()
	String prefix = ""
	if (name.startsWith('lib')) {
		prefix = 'lib'
		name = name.substring(3)
	}
	File parent = binaryFile.getParentFile()
	
	if (name.contains("TestLibrary")) {			// TestLibrary[64][d].dll ==> TestLibrary[d].dll
		String suffix = ""
		String debug= ""
		int extensionSeparator = name.lastIndexOf('.')
		if (extensionSeparator != -1) {
			suffix = name.substring(extensionSeparator);
			if (name.charAt(extensionSeparator - 1) == 'd')
				debug = 'd'
		}
		return new File(parent, prefix + "TestLibrary" + debug + suffix)
	}
		
	return new File(parent, prefix + "Poco" + name);
}
File suffixByArch(File binaryFile, Platform platform) {
	if (!platform.operatingSystem.windows) {
		return binaryFile
	}
	String name = binaryFile.getName()
	String suffix = ''
	if (platform.architecture.name == 'x86') {
		suffix = ''
	} else
	if (platform.architecture.name == 'x86-64') {
		suffix = '64'
	} else {
		throw new GradleException("Unknown architecture: " + platform.architecture.name)
	}
	int extensionSeparator = name.lastIndexOf('.')
	if (extensionSeparator == -1) {
		return new File(parent, name + suffix)
	}
	File parent = binaryFile.getParentFile()
	return new File(parent, name.substring(0, extensionSeparator) + suffix + name.substring(extensionSeparator));
}
File toLocalBin(File binaryFile, Platform platform) {
	String name = binaryFile.getName()
	String target
	if (platform.architecture.name == 'x86') {
		target = 'bin'
	} else
	if (platform.architecture.name == 'x86-64') {
		target = 'bin64'
	} else {
		throw new GradleException("Unknown architecture: " + platform.architecture.name)
	}
	File parent = new File(target)
	return new File(parent, name);
}
File toBin(File sharedFile, Platform platform) {
	File parent = sharedFile.parentFile
	if (parent.canonicalPath.contains("testsuite"))
		return sharedFile;
	if (parent.canonicalPath.contains("sample"))
		return sharedFile;
		
	if (platform.operatingSystem.linux) {
		return toLib(sharedFile, platform)
	}

	String name = sharedFile.getName()
	String target
	if (platform.architecture.name == 'x86') {
		target = 'bin'
	} else
	if (platform.architecture.name == 'x86-64') {
		target = 'bin64'
	} else {
		throw new GradleException("Unknown architecture: " + platform.architecture.name)
	}
	File newParent = new File(rootDir, target)
	return new File(newParent, name);
}
File toLib(File linkFile, Platform platform) {
	File parent = linkFile.parentFile
	if (parent.canonicalPath.contains("testsuite"))
		return linkFile;
	if (parent.canonicalPath.contains("sample"))
		return linkFile;
		
	// On macOS, it creates a dylib file which is the shared and import library
	if (platform.operatingSystem.macOsX) {
		return toBin(linkFile, platform)
	}

	String name = linkFile.getName()
	String target
	if (platform.architecture.name == 'x86') {
		target = 'lib'
	} else
	if (platform.architecture.name == 'x86-64') {
		target = 'lib64'
	} else {
		throw new GradleException("Unknown architecture: " + platform.architecture.name)
	}
	File newParent = new File(rootDir, target )
	return new File(newParent, name);
}
File toStatic(File staticFile, Platform platform) {
	String name = staticFile.getName()
	String target
	if (platform.architecture.name == 'x86') {
		target = 'lib'
	} else
	if (platform.architecture.name == 'x86-64') {
		target = 'lib64'
	} else {
		throw new GradleException("Unknown architecture: " + platform.architecture.name)
	}
	File parent = new File(rootDir, target)
	return new File(parent, name);
}
File toPDB(File binaryFile) {
	String name = binaryFile.getName()
	File parent = binaryFile.getParentFile()
	int extensionSeparator = name.lastIndexOf('.')
	if (extensionSeparator != -1)
		name = name.substring(0, extensionSeparator)
	return new File(parent, name + ".pdb")
}
File makePreBuildLibrary(String name, Platform platform) {
	File pbl
	if (platform.architecture.name == 'x86') {
		pbl = new File(WDKHome + "/Lib/" + WDKVers + "/um/x86/" + name + ".lib")

	} else
	if (platform.architecture.name == 'x86-64') {
		pbl = new File(WDKHome + "/Lib/" + WDKVers + "/um/x64/" + name + ".lib")
	} else
	if (platform.architecture.name == 'arm-v7') {
		pbl = new File(WDKHome + "/Lib/" + WDKVers + "/um/arm-v7/" + name + ".lib")
	} else
	if (platform.architecture.name == 'ia-64') {
		pbl = new File(WDKHome + "/Lib/" + WDKVers + "/um/ia-64/" + name + ".lib")
	} else {
		throw new GradleException("Unknown architecture: " + platform.architecture.name)
	}
	return pbl
}
class SliceTasksPlugin extends RuleSource {
	@Mutate
	void createBuildSliceTask(ModelMap<Task> tasks, BinaryContainer binaries, BuildTypeContainer buildTypes) {
		tasks.create("slice") {
			dependsOn binaries.withType(NativeBinarySpec).findAll { 
				it.buildable && 
				it.buildType == buildTypes.debug && 
				it.targetPlatform.architecture.name == 'x86' &&
				it instanceof SharedLibraryBinarySpec
			}
		}
	}
}

def getSelectedVisualStudioToolChain() {
    String selector = System.properties["VS"]

    if (selector == null) {
        selector = "VS2017"
    }

    String installDir = null
    String toolset = null;
	String vsvers = null;
    switch (selector) {
        case "VS2008": 
			installDir = "file://C:/Program Files (x86)/Microsoft Visual Studio 9.0";vsvers="vs90";toolset = "v90";
		break;
        case "VS2010": 
			installDir = "file://C:/Program Files (x86)/Microsoft Visual Studio 10.0";vsvers="vs100";toolset = "v100";
		break;
		case "VS2012": 
			installDir = "file://C:/Program Files (x86)/Microsoft Visual Studio 11.0";vsvers="vs110";toolset = "v110";
		break;
		case "VS2013": 
			installDir = "file://C:/Program Files (x86)/Microsoft Visual Studio 12.0";vsvers="vs120";toolset = "v120";
		break;
    	case "VS2015": 
			installDir = "file://C:/Program Files (x86)/Microsoft Visual Studio 14.0";vsvers="vs140";toolset = "v140";
		break;
    	case "VS2017": 
			installDir = "file://C:/Program Files (x86)/Microsoft Visual Studio/2017/Community";vsvers="vs150";toolset = "v141";
		break;
        default:
            throw new IllegalArgumentException()
    }

    return [
        vsyear:		selector,
		vsvers: 	vsvers,
		toolset: 	toolset,
        installDir: installDir,
    ]
}

allprojects {
	buildDir = new File('guild')	            // DO NOT REMOVE OR CHANGE to 'build' since 'build' is a Poco directory
	file('bin').mkdirs()
	file('bin64').mkdirs()
	file('lib').mkdirs()
	file('lib64').mkdirs()
}
subprojects {
/*
	clean.doFirst {
		file(projectDir, 'bin').delete()
		file(projectDir, 'bin64').delete() 
		file(projectDir, 'lib').delete() 
		file(projectDir, 'lib64').delete() 
	}
*/
	apply plugin:	'c'
	apply plugin:	'cpp'
	apply plugin:	'cppunit-test-suite'
 	apply plugin:	'windows-resources'
	apply plugin:	'windows-messages'
	apply plugin: 	SliceTasksPlugin
	

	model {
		buildTypes {
			release
			debug
		}
    	toolChains {
        	def vsToolChain = getSelectedVisualStudioToolChain()
        	create(vsToolChain.vsyear, VisualCpp) {
        	    installDir vsToolChain.installDir
        	}
    	}

/*		toolChains {
			VS2008(VisualCpp) {
				installDir = VS2008installDir
			}
			VS2010(VisualCpp) {
				installDir = VS2010installDir
			}
			VS2012(VisualCpp) {
				installDir = VS2012installDir
			}
			VS2013(VisualCpp) {
				installDir = VS2013installDir
			}
			VS2015(VisualCpp) {
				installDir = VS2015installDir
			}
			VS2017(VisualCpp) {
				installDir "C:/Program Files (x86)/Microsoft Visual Studio/2017/Community"
				eachPlatform {
					cppCompiler.withArguments { args ->
						args << "-DFRENCH"
					}
				}
			}

			gcc(Gcc) {
				// Uncomment to use a GCC install that is not in the PATH
				// path "/usr/bin/gcc"
			}
			clang(Clang)

		}
*/		
		platforms {
			win32 {
				operatingSystem "windows"
				architecture 'x86'
			}
			win64 {
				operatingSystem "windows"
				architecture 'x64'
			}
			linux32 {
				operatingSystem "linux"
				architecture 'x86'
			}
			linux64 {
				operatingSystem "linux"
				architecture 'x64'
			}
			macos {
				operatingSystem "macosx"
				architecture 'x64'
			}
		}

		flavors {
			bundled
//			unbundled
		}
		repositories {
			libs(PrebuiltLibraries) {
				WS2_32 {
					headers.srcDir WDKHome + "/Include/" + WDKVers + "/um/x86"
					binaries.withType(StaticLibraryBinary) {
						if (targetPlatform.operatingSystem.windows) {
							staticLibraryFile = makePreBuildLibrary("WS2_32", targetPlatform)
							println "staticLibraryFile=" + staticLibraryFile
						}
					}
				}
				def opensslWindowsHome = new File(rootDir, "openssl/build")
				def opensslBrewHome = new File('/usr/local/opt/openssl')
				def opensslLinuxHome = new File('/usr/lib/x86_64-linux-gnu')
				
				crypto {
					binaries.withType(StaticLibraryBinary) {
						def libName = "foobar"
						if (buildType == buildTypes.debug) {
							if (targetPlatform.name == 'win32') {
					           	headers.srcDir "$opensslWindowsHome/include"
								libName = 'libcryptod.lib'
								staticLibraryFile = new File("$opensslWindowsHome/win32/lib/debug/$libName")
							} else if (targetPlatform.name == 'win64') {
					           	headers.srcDir "$opensslWindowsHome/include"
								libName = 'libcryptod.lib'
								staticLibraryFile = new File("$opensslWindowsHome/win64/lib/debug/$libName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								headers.srcDir "$opensslBrewHome/include"
								libName = 'libcrypto.a'
								staticLibraryFile = new File("$opensslBrewHome/lib/$libName")
							} else if (targetPlatform.operatingSystem.linux) {
					           	headers.srcDir "$openssl64LinuxInc/include"
								libName = 'libcrypto.a'
								staticLibraryFile = new File("$openssl64LinuxLib/$libName")
							}
						} else
						if (buildType == buildTypes.release) {
							if (targetPlatform.name == 'win32') {
					           	headers.srcDir "$opensslWindowsHome/include"
								libName = 'libcrypto.lib'
								staticLibraryFile = new File("$opensslWindowsHome/win32/lib/release/$libName")
							} else if (targetPlatform.name == 'win64') {
					           	headers.srcDir "$opensslWindowsHome/include"
								libName = 'libcrypto.lib'
								staticLibraryFile = new File("$opensslWindowsHome/win64/lib/release/$libName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								headers.srcDir "$opensslBrewHome/include"
								libName = 'libcrypto.a'
								staticLibraryFile = new File("$opensslBrewHome/lib/$libName")
							} else if (targetPlatform.operatingSystem.linux) {
					           	headers.srcDir "$openssl64LinuxInc/include"
								libName = 'libcrypto.a'
								staticLibraryFile = new File("$openssl64LinuxLib/$libName")
							}
						} else {
							throw new GradleException("Unknown buildType" + buildType)
						}
					}
					binaries.withType(SharedLibraryBinary) {
						def dllName
						def linkName
						if (buildType == buildTypes.debug) {
							if (targetPlatform.name == 'win32') {
					           	headers.srcDir "$opensslWindowsHome/include"
								dllName = 'libcryptod.dll'
								linkName = 'libcryptod.lib'
								sharedLibraryFile	 = new File("$opensslWindowsHome/win32/bin/debug/$dllName")
								sharedLibraryLinkFile = new File("$opensslWindowsHome/win32/bin/debug/$linkName")
							} else if (targetPlatform.name == 'win64') {
					           	headers.srcDir "$opensslWindowsHome/include"
								dllName = 'libcryptod.dll'
								linkName = 'libcryptod.lib'
								sharedLibraryFile	 = new File("$opensslWindowsHome/win64/bin/debug/$dllName")
								sharedLibraryLinkFile = new File("$opensslWindowsHome/win64/bin/debug/$linkName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								headers.srcDir "$opensslBrewHome/include"
								dllName = 'libcrypto.dylib'
								linkName = 'libcrypto.dylib'
								sharedLibraryFile	 = new File("$opensslBrewHome/lib/$dllName")
								sharedLibraryLinkFile = new File("$opensslBrewHome/lib/$linkName")
							} else if (targetPlatform.operatingSystem.linux) {
					           	headers.srcDir "$openssl64LinuxInc/include"
								dllName = 'libcrypto.so'
								linkName = 'libcrypto.a'
								sharedLibraryFile	 = new File("$openssl64LinuxLib/$dllName")
								sharedLibraryLinkFile = new File("$openssl64LinuxLib/$linkName")
							}
						} else
						if (buildType == buildTypes.release) {
							if (targetPlatform.name == 'win32') {
					           	headers.srcDir "$opensslWindowsHome/include"
								dllName = 'libcrypto.dll'
								linkName = 'libcrypto.lib'
								sharedLibraryFile	 = new File("$opensslWindowsHome/win32/bin/release/$dllName")
								sharedLibraryLinkFile = new File("$opensslWindowsHome/win32/bin/release/$linkName")
							} else if (targetPlatform.name == 'win64') {
					           	headers.srcDir "$opensslWindowsHome/include"
								dllName = 'libcrypto.dll'
								linkName = 'libcrypto.lib'
								sharedLibraryFile	 = new File("$opensslWindowsHome/win64/bin/release/$dllName")
								sharedLibraryLinkFile = new File("$opensslWindowsHome/win64/bin/release/$linkName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								headers.srcDir "$opensslBrewHome/include"
								dllName = 'libcrypto.dylib'
								linkName = 'libcrypto.dylib'
								sharedLibraryFile	 = new File("$opensslBrewHome/lib/$dllName")
								sharedLibraryLinkFile = new File("$opensslBrewHome/lib/$linkName")
							} else if (targetPlatform.operatingSystem.linux) {
					           	headers.srcDir "$openssl64LinuxInc/include"
								dllName = 'libcrypto.so'
								linkName = 'libcrypto.a'
								sharedLibraryFile	 = new File("$openssl64LinuxLib/$dllName")
								sharedLibraryLinkFile = new File("$openssl64LinuxLib/$linkName")
							}
						} else {
							throw new GradleException("Unknown buildType" + buildType)
						}
					}
				}
				ssl {
					binaries.withType(StaticLibraryBinary) {
						def libName
						if (buildType == buildTypes.debug) {
							if (targetPlatform.name == 'win32') {
					           	headers.srcDir "$opensslWindowsHome/include"
								libName = 'libssld.lib'
								staticLibraryFile = new File("$opensslWindowsHome/win32/lib/debug/$libName")
							} else if (targetPlatform.name == 'win64') {
					           	headers.srcDir "$opensslWindowsHome/include"
								libName = 'libssl.lib'
								staticLibraryFile = new File("$opensslWindowsHome/win64/lib/debug/$libName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								headers.srcDir "$opensslBrewHome/include"
								libName = 'libssl.a'
								staticLibraryFile = new File("$opensslBrewHome/lib/$libName")
							} else if (targetPlatform.operatingSystem.linux) {
					           	headers.srcDir "$openssl64LinuxInc/include"
								libName = 'libssl.a'
								staticLibraryFile = new File("$openssl64LinuxLib", "$libName")
							}
						} else
						if (buildType == buildTypes.release) {
							if (targetPlatform.name == 'win32') {
					           	headers.srcDir "$opensslWindowsHome/include"
								libName = 'libssl.lib'
								staticLibraryFile = new File("$opensslWindowsHome/win32/lib/release/$libName")
							} else if (targetPlatform.name == 'win64') {
					           	headers.srcDir "$opensslWindowsHome/include"
								libName = 'libssl.lib'
								staticLibraryFile = new File("$opensslWindowsHome/win64/lib/release/$libName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								headers.srcDir "$opensslBrewHome/include"
								libName = 'libssl.a'
								staticLibraryFile = new File("$opensslBrewHome/lib/$libName")
							} else if (targetPlatform.operatingSystem.linux) {
					           	headers.srcDir "$openssl64LinuxInc/include"
								libName = 'libssl.a'
								staticLibraryFile = new File("$openssl64LinuxLib/$libName")
							}
						} else {
							throw new GradleException("Unknown buildType" + buildType)
						}
					}
					binaries.withType(SharedLibraryBinary) {
						def dllName
						def linkName
						if (buildType == buildTypes.debug) {
							if (targetPlatform.name == 'win32') {
					           	headers.srcDir "$opensslWindowsHome/include"
								dllName = 'libssld.dll'
								linkName = 'libssld.lib'
								sharedLibraryFile	 = new File("$opensslWindowsHome/win32/bin/debug/$dllName")
								sharedLibraryLinkFile = new File("$opensslWindowsHome/win32/bin/debug/$linkName")
							} else if (targetPlatform.name == 'win64') {
					           	headers.srcDir "$opensslWindowsHome/include"
								dllName = 'libssld.dll'
								linkName = 'libssld.lib'
								sharedLibraryFile	 = new File("$opensslWindowsHome/win64/bin/debug/$dllName")
								sharedLibraryLinkFile = new File("$opensslWindowsHome/win64/bin/debug/$linkName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								headers.srcDir "$opensslBrewHome/include"
								dllName = 'libssl.dylib'
								linkName = 'libssl.dylib'
								sharedLibraryFile	 = new File("$opensslBrewHome/lib/$dllName")
								sharedLibraryLinkFile = new File("$opensslBrewHome/lib/$linkName")
							} else if (targetPlatform.operatingSystem.linux) {
                               	def File openssl64LinuxLibFile = new File("$openssl64LinuxLib")
					           	headers.srcDir "$openssl64LinuxInc/include"
								dllName  = "libssl.so"
								linkName = "libssl.a"
								sharedLibraryFile	 = new File(openssl64LinuxLibFile, dllName)
								sharedLibraryLinkFile = new File(openssl64LinuxLibFile, linkName)
							}
						} else if (buildType == buildTypes.release) {
							if (targetPlatform.name == 'win32') {
					           	headers.srcDir "$opensslWindowsHome/include"
								dllName = 'libssl.dll'
								linkName = 'libssl.lib'
								sharedLibraryFile	 = new File("$opensslWindowsHome/win32/bin/release/$dllName")
								sharedLibraryLinkFile = new File("$opensslWindowsHome/win32/bin/release/$linkName")
							} else if (targetPlatform.name == 'win64') {
					           	headers.srcDir "$opensslWindowsHome/include"
								dllName = 'libssl.dll'
								linkName = 'libssl.lib'
								sharedLibraryFile	 = new File("$opensslWindowsHome/win64/bin/release/$dllName")
								sharedLibraryLinkFile = new File("$opensslWindowsHome/win64/bin/release/$linkName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								headers.srcDir "$opensslBrewHome/include"
								dllName = 'libssl.dylib'
								linkName = 'libssl.dylib'
								sharedLibraryFile	 = new File("$opensslBrewHome/lib/$dllName")
								sharedLibraryLinkFile = new File("$opensslBrewHome/lib/$linkName")
							} else if (targetPlatform.operatingSystem.linux) {
					           	headers.srcDir "$openssl64LinuxInc/include"
								dllName = 'libssl.so'
								linkName = 'libssl.a'
								sharedLibraryFile	 = new File("$openssl64LinuxLib/$dllName")
								sharedLibraryLinkFile = new File("$openssl64LinuxLib/$linkName")
							}
						} else {
							throw new GradleException("Unknown buildType" + buildType)
						}
					}
				}
			}
		}
		components {
			withType(NativeComponentSpec) {
				targetPlatform "win32"
				targetPlatform "win64"
				targetPlatform "linux32"
				targetPlatform "linux64"
				targetPlatform "macos"

				binaries.withType(NativeTestSuiteBinarySpec) {
					if (buildType == buildTypes.debug) {
						if (it instanceof NativeExecutableBinarySpec) {
							executable.file = toLocalBin(appendDebugSuffix(executable.file), targetPlatform)
						}
					} else
					if (buildType == buildTypes.release) {
						if (it instanceof NativeExecutableBinarySpec) {
							executable.file = toLocalBin(executable.file, targetPlatform)
						} 
					}
				}
				binaries.withType(NativeBinarySpec) {

					if (toolChain in Clang) {
						cppCompiler.args "-std=c++11"
					}
					if (buildType == buildTypes.debug) {
						if (it instanceof SharedLibraryBinarySpec) {
							sharedLibraryFile	  = toBin(prefixByPoco(appendDebugSuffix(suffixByArch(sharedLibraryFile, targetPlatform))), targetPlatform)
							sharedLibraryLinkFile = toLib(prefixByPoco(appendDebugSuffix(sharedLibraryLinkFile)), targetPlatform)

							if (targetPlatform.operatingSystem.windows) {
								// WINDOWS ONLY
								linker.args "/implib:${sharedLibraryLinkFile}"  // For MSVC only
								// use the following for MinGW
								// linker.args "-Wl,--out-implib,${sharedLibraryLinkFile}"
								// This next part is simply to ensure the directory is created as the compiler (tested on MSVC only) won't create it
								def binary = it  // Simply to expose the binary in the `doFirst`
								tasks.withType(LinkSharedLibrary) {
									doFirst {
										binary.sharedLibraryLinkFile.parentFile.mkdirs()
									}
								}
							}
						} else
						if (it instanceof StaticLibraryBinarySpec) {
							staticLibraryFile = toStatic(prefixByPoco(appendDebugSuffix(appendStaticSuffix(staticLibraryFile))), targetPlatform)
							def binary = it
							tasks.withType(CreateStaticLibrary) {
								doFirst {
									binary.staticLibraryFile.parentFile.mkdirs()
								}
							}
						} else
						if (it instanceof SemiStaticLibraryBinarySpec) {
							semiStaticLibraryFile = toStatic(prefixByPoco(appendDebugSuffix(appendSemiStaticSuffix(semiStaticLibraryFile))), targetPlatform)
						} else
						if (it instanceof NativeExecutableBinarySpec) {
							executable.file = toBin(appendDebugSuffix(executable.file), targetPlatform)
						} else {
							throw new GradleException("Unknown native library binary")
						}
					} else
					if (buildType == buildTypes.release) {
						if (it instanceof SharedLibraryBinarySpec) {
							sharedLibraryFile     = toBin(prefixByPoco(suffixByArch(sharedLibraryFile, targetPlatform)), targetPlatform)
							sharedLibraryLinkFile = toLib(prefixByPoco(sharedLibraryLinkFile), targetPlatform)

							if (targetPlatform.operatingSystem.windows) {
								// WINDOWS ONLY
								linker.args "/implib:${sharedLibraryLinkFile}"  // For MSVC only
								// use the following for MinGW
								// linker.args "-Wl,--out-implib,${sharedLibraryLinkFile}"
								// This next part is simply to ensure the directory is created as the compiler (tested on MSVC only) won't create it
								def binary = it  // Simply to expose the binary in the `doFirst`
								tasks.withType(LinkSharedLibrary) {
									doFirst {
										binary.sharedLibraryLinkFile.parentFile.mkdirs()
									}
								}
							}
						} else
						if (it instanceof StaticLibraryBinarySpec) {
							staticLibraryFile = toStatic(prefixByPoco(appendStaticSuffix(staticLibraryFile)), targetPlatform)
							def binary = it
							tasks.withType(CreateStaticLibrary) {
								doFirst {
									binary.staticLibraryFile.parentFile.mkdirs()
								}
							}
						} else
						if (it instanceof SemiStaticLibraryBinarySpec) {
							semiStaticLibraryFile = toStatic(prefixByPoco(appendSemiStaticSuffix(semiStaticLibraryFile)), targetPlatform)
							def binary = it
							tasks.withType(CreateSemiStaticLibrary) {
								doFirst {
									binary.semiStaticLibraryFile.parentFile.mkdirs()
								}
							}
						} else
						if (it instanceof NativeExecutableBinarySpec) {
							executable.file = toBin(executable.file, targetPlatform)
						} else {
							throw new GradleException("Unknown native library binary")
						} 
					} else {
						throw new GradleException("Unknown buildType" + buildType)
					}
				}
			}
		}


		binaries {
			all {
				if (flavor != flavors.bundled) {
					cCompiler.define 'POCO_UNBUNDLED'
					cppCompiler.define 'POCO_UNBUNDLED'
				}
				if (buildType == buildTypes.debug) {
					cCompiler.define '_DEBUG'
					cppCompiler.define '_DEBUG'
				} else 
				if (buildType == buildTypes.release) {
					cCompiler.define 'NDEBUG'
					cppCompiler.define 'NDEBUG'
				}
			
				if (toolChain in Gcc) {
					cppCompiler.define "_XOPEN_SOURCE=600"
					cppCompiler.define "_REENTRANT"
					cppCompiler.define "_THREAD_SAFE"
					cppCompiler.define "_FILE_OFFSET_BITS=64"
					cppCompiler.define "_LARGEFILE64_SOURCE"
					cppCompiler.define "POCO_HAVE_FD_EPOLL"
					cppCompiler.define "POCO_HAVE_ADDRINFO"
					cppCompiler.define "POCO_HAVE_LIBRESOLV"
					cppCompiler.args "-std=c++11"
					cppCompiler.args "-fPIC"

					linker.args "-lrt"
					linker.args "-ldl"
					linker.args "-lpthread"
				}
				if (toolChain in VisualCpp) {
					if (targetPlatform == platforms.win64) {
						linker.args '/MACHINE:X64'
					} else {
						linker.args '/MACHINE:X86'
					}
					if (buildType == buildTypes.debug) {
						cCompiler.args '/Zi'
						cppCompiler.args '/Zi'
						linker.args '/DEBUG'
					}
					cCompiler.args '/RTC1'
					cCompiler.args '/FS'
					cCompiler.args '/Zc:wchar_t'
					cCompiler.args '/Zc:inline'
					cCompiler.args '/Zc:forScope'
					cCompiler.args '/GR'
					cCompiler.args '/GF'
					cCompiler.args '/EHsc'
					cCompiler.args '/bigobj'
					cCompiler.define 'WIN32'
					cCompiler.define '_WIN32'
					cCompiler.define '_WINDOWS'
					cCompiler.define '_MBCS'

					cppCompiler.args '/RTC1'
					cppCompiler.args '/FS'
					cppCompiler.args '/Zc:wchar_t'
					cppCompiler.args '/Zc:inline'
					cppCompiler.args '/Zc:forScope'
					cppCompiler.args '/GR'
					cppCompiler.args '/GF'
					cppCompiler.args '/EHsc'
					cppCompiler.args '/bigobj'
					cppCompiler.define 'WIN32'
					cppCompiler.define '_WIN32'
					cppCompiler.define '_WINDOWS'
					cppCompiler.define '_MBCS'
					
					linker.args 'kernel32.lib'
					linker.args 'user32.lib'
					linker.args 'gdi32.lib'
					linker.args 'winspool.lib'
					linker.args 'comdlg32.lib'
					linker.args 'advapi32.lib'
					linker.args 'shell32.lib'
					linker.args 'ole32.lib'
					linker.args 'oleaut32.lib'
					linker.args 'uuid.lib'
					
					linker.args '/NXCOMPAT' 
					linker.args '/OPT:REF' 
					linker.args '/INCREMENTAL:NO' 
//					linker.args '/MANIFEST' 
//					linker.args '/MANIFESTUAC:"level='asInvoker' uiAccess='false'"' 
					linker.args '/OPT:ICF' 
					linker.args '/NOLOGO' 
					linker.args '/SUBSYSTEM:CONSOLE'
				}
			}
			withType(SharedLibraryBinarySpec) {
				if (toolChain in VisualCpp) {
					cCompiler.define   '_USRDLL'
					cCompiler.define   '_WINDLL'
					cppCompiler.define '_USRDLL'
					cppCompiler.define '_WINDLL'
					if (buildType == buildTypes.debug) {
						cCompiler.args "/MDd"
						cppCompiler.args "/MDd"
					} else 
					if (buildType == buildTypes.release) {
						cCompiler.args "/MD"
						cppCompiler.args "/MD"
					}
				}
				if (toolChain in Gcc) {
					linker.args "-Wl,-rpath,$rootDir/lib64"   //FIXME
				}
			}
			withType(StaticLibraryBinarySpec) {
				if (toolChain in VisualCpp) {
					cCompiler.define   '_LIB'
					cCompiler.define   'POCO_STATIC'
					cppCompiler.define '_LIB'
					cppCompiler.define 'POCO_STATIC'
					if (buildType == buildTypes.debug) {
						cCompiler.args "/MTd"
						cCompiler.args "/Fd" + toStatic(toPDB(staticLibraryFile), targetPlatform)
						cppCompiler.args "/MTd"
						cppCompiler.args "/Fd" + toStatic(toPDB(staticLibraryFile), targetPlatform)
					} else 
					if (buildType == buildTypes.release) {
						cCompiler.args "/MT"
						cppCompiler.args "/MT"
					} else {
						throw new GradleException("Unknown buildType" + buildType)
					}
				}
				if (toolChain in Gcc) {
				}
			}
			withType(SemiStaticLibraryBinarySpec) {
				if (toolChain in VisualCpp) {
					cCompiler.define   '_LIB'
					cCompiler.define   'POCO_STATIC'
					cppCompiler.define '_LIB'
					cppCompiler.define 'POCO_STATIC'
					if (buildType == buildTypes.debug) {
						cCompiler.args "/MDd"
						cCompiler.args "/Fd" + toStatic(toPDB(semiStaticLibraryFile), targetPlatform)
						cppCompiler.args "/MDd"
						cppCompiler.args "/Fd" + toStatic(toPDB(semiStaticLibraryFile), targetPlatform)
					} else 
					if (buildType == buildTypes.release) {
						cCompiler.args "/MD"
						cppCompiler.args "/MD"
					} else {
						throw new GradleException("Unknown buildType" + buildType)
					}
				}
				if (toolChain in Gcc) {
				}
			}
			withType(NativeExecutableBinarySpec) {
				if (toolChain in VisualCpp) {
					if (buildType == buildTypes.debug) {
						cCompiler.args "/MDd"
						cppCompiler.args "/MDd"
					} else 
					if (buildType == buildTypes.release) {
						cCompiler.args "/MD"
						cppCompiler.args "/MD"
					} else {
						throw new GradleException("Unknown buildType" + buildType)
					}
				}
				if (toolChain in Gcc) {
				}
			}
			withType(org.gradle.nativeplatform.test.cppunit.CppUnitTestSuiteBinarySpec) {
				tasks.run.environment "POCO_BASE", "$rootDir"
				
				String PATH = tasks.run.environment.get("Path")
				
				if (targetPlatform.name.equals("win32")) {
					PATH = "$rootDir/bin;$PATH"
				} else
				if (targetPlatform.name.equals("win64")) {
					PATH = "$rootDir/bin64;$PATH"
				}
				if (targetPlatform.name.startsWith("win")) 
					PATH = PATH.replace('/', '\\')
					
				tasks.run.environment "Path", PATH
			}
		}
	}
	tasks.withType(RunTestExecutable) {
		String CPPUNIT_IGNORE;
		CPPUNIT_IGNORE =  'class CppUnit::TestCaller<class NTPClientTest>.testTimeSync';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class RawSocketTest>.testEchoIPv4';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class RawSocketTest>.testSendToReceiveFromIPv4';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class ICMPClientTest>.testPing';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class ICMPClientTest>.testBigPing';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class HTTPSClientSessionTest>.testProxy';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class HTTPSStreamFactoryTest>.testProxy';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class TCPServerTest>.testReuseSocket';

		environment "CPPUNIT_IGNORE", "\"$CPPUNIT_IGNORE\""

		args test
	}
}
tasks.withType(CppCompile) {
	maxParallelForks = 2
}

task PocoDocIni {
    def file = new File("$rootDir/PocoDoc/PocoDoc.ini")
    file.createNewFile()
    file.text = """
PocoBuild=$rootDir
PocoBase=$rootDir
PocoDoc.output=releases/poco-${version}-all-doc
PocoDoc.version=${version}-all
"""
	if (os.windows) {
		def	String javaVCH = VCHome.replace('\\','/')
		def	String javaCLP = CLPath.replace('\\','/')
		def	String javaWDK = WDKHome + "/Include/" + WDKVers
		javaWDK = javaWDK.replace('\\','/')
		
 		file.text += """
Includes=-I${postgres32Home}/include,-I${mysql32Home}/include,-ICppParser/include,-ICppUnit/include,-ICrypto/include,-IEncodings/include,-IData/include,-IData/include,-IData/MySQL/include,-IData/ODBC/include,-IData/PostgreSQL/include,-IData/SQLite/include, -IData/SQLite/src,-IFoundation/include,-IJSON/include,-IMongoDB/include,-INet/include,-INetSSL_OpenSSL/include,-INetSSL_Win/include,-IRedis/include,-IUtil/include,-IXML/include,-IZip/include,-ISevenZip/include,-IPDF/include
VCH=${javaVCH}
WDK=${javaWDK}
CLP=${javaCLP}
"""
	} else {
	}
}
task pocoDoc(type: Exec) {
	dependsOn ':PocoDoc::assemble'
	dependsOn PocoDocIni
	if (os.windows) {
		environment "Path", "$rootDir\\bin;$Path"
		println environment.Path
		
		executable "PocoDoc/bin/PocoDoc.exe"
		args "/config=$rootDir/PocoDoc/cfg/mkdoc-gradle.xml"
		args "/config=$rootDir/PocoDoc/PocoDoc.ini"
	} 
	if (os.linux) {
		environment "LD_LIBRARY_PATH", "$rootDir/lib64:$LD_LIBRARY_PATH"
		executable "PocoDoc/bin64/PocoDoc"
		args "-config=$rootDir/PocoDoc/cfg/mkdoc-gradle.xml"
		args "-config=$rootDir/PocoDoc/PocoDoc.ini"
	}
	if (os.macOsX) {
		//FIXME environment "LD_LIBRARY_PATH", "$rootDir/bin:$LD_LIBRARY_PATH"
		args "-config=$rootDir/PocoDoc/cfg/mkdoc-gradle.xml"
		args "-config=$rootDir/PocoDoc/PocoDoc.ini"
	}
//	inputs.files(tasks.getByPath(':production').outputs.files)
	inputs.file(executable)
	inputs.files(fileTree("doc").filter { it.isFile() })
	inputs.file(new File("$rootDir/PocoDoc/cfg/mkdoc-gradle.xml"))
	outputs.file(new File("releases/poco-${version}-all-doc/index.html"))
}
task zipDoc(type: Zip) {
	from "releases/poco-${version}-all-doc/"
	include '*'
	include '*/*'
	archiveName "poco-${version}-all-doc.zip"
	destinationDir(file('releases'))
	inputs.file(new File("releases/$version-all-doc/index.html"))
	outputs.file(new File("releases/poco-${version}-all-doc.zip"))
	dependsOn pocoDoc
}

def candle(vsyear, toolset, version, arch, os) {
	return tasks.create("Candle-${vsyear}-${toolset}-${version}-${arch}", Exec) {
		def Set<Task> pocos = project.getTasksByName('poco', true)
		setDependsOn(pocos)
		dependsOn ':pocoDoc'
		workingDir "packaging/Windows/WiX"
		String wixobj	= "Poco-$toolset-$arch-${version}.wixobj"

		executable "${WiXHome}/bin/Candle.exe"
		args "-arch", "${arch}"
		args "-dVSYEAR=${vsyear}"
		args "-dVERSION=${version}"
		args "-dPOCO=${rootDir}"
		args "-dPlatform=${arch}"
		args "-dToolset=${toolset}"
		args "-ext", "${WiXHome}/bin/WixUIExtension.dll"
		args "-out", "${vsyear}/${wixobj}"
		args "Poco.wxs"
		
		def File index = new File("$rootDir/releases/poco-$version-all-doc/index.html")
		inputs.file(index)

		inputs.files(pocos.inputs.files)
		inputs.file(new File(workingDir, "Poco.wxs"))
		inputs.files(project.getTasksByName('poco', true).outputs.files)
		
		def File output = new File(workingDir,"${vsyear}/${vsyear}-Poco-$version-${arch}.wixobj")
		outputs.file(output)

		onlyIf(new Spec<Exec>() {
			boolean isSatisfiedBy(Exec task) {
				   return os.windows;
			}
		});
	}
}
def light(vsyear, toolset, version, arch, os) {
	return tasks.create("Light-${vsyear}-${toolset}-${version}-${arch}", Exec) {
		dependsOn candle(vsyear, toolset, version, arch, os)
		workingDir "packaging/Windows/WiX"
		String msi 		= "Poco-$toolset-$arch-${version}.msi"
		String wixobj	= "Poco-$toolset-$arch-${version}.wixobj"
		
		executable "${WiXHome}/bin/Light.exe"
		args "-cultures:null"
		args "-ext", "${WiXHome}/bin/WixUIExtension.dll"
		args "-out", "${vsyear}/${msi}"
		args "${vsyear}/${wixobj}"

		def File input = new File(workingDir, "${vsyear}/${wixobj}")
		inputs.file(input)
		def File output = new File(workingDir, "${vsyear}/${msi}")
		outputs.file(output)

		onlyIf(new Spec<Exec>() {
			boolean isSatisfiedBy(Exec task) {
				   return os.windows;
			}
		});
	}
}
task wix() {
	String vsyear  = getSelectedVisualStudioToolChain().vsyear
	String toolset = getSelectedVisualStudioToolChain().toolset
	dependsOn 		light(vsyear, toolset, version, 'x86', os)
	dependsOn 		light(vsyear, toolset, version, 'x64', os)
	onlyIf(new Spec<Task>() {
		boolean isSatisfiedBy(Task task) {
			   return os.windows;
		}
	});
}

ext.commoNuspecMetadata = [
	version:     	"1.9.1",
	owners:			'Guenter Obiltschnig & Aleksandar Fabijanic',
	authors:        'Applied Informatics & Contributors',
	projectUrl: 	'https://pocoproject.org/',
	licenseUrl:		'https://pocoproject.org/license.html',
	iconUrl:		'https://avatars1.githubusercontent.com/u/201918?v=4&s=200',
	copyright: 		'Applied Informatics copyright 2018',
	requireLicenseAcceptance: false,
	description:	'Modern, powerful open source C++ class libraries for building network- and internet-based applications that run on desktop, server, mobile and embedded systems.',
	tags:			'native string filesystem thread date log event regex uri uuid cache native nativepackage sockets mime http ftp mail pop3 smtp html sax sax2 dom xml',
	copyright:		'Copyright 2018',
	releaseNotes:	'releaseNotes'
]
def nugetCopyTarget(arch) {
	return tasks.create("nugetCopyTarget-${arch}", Copy) {
		String toolset = getSelectedVisualStudioToolChain().toolset
		from file("$rootDir/packaging/Windows/NuGet/Pocoproject.Poco.${arch}.targets")
		rename { String filename ->
			int insert = filename.indexOf(arch)
			return filename[0..insert - 1] + toolset + "." + filename.substring(insert)
		}
		into file("$rootDir/packaging/Windows/NuGet")
	}
}
def pocoNugetSpec(arch) {
	return tasks.create("pocoNugetSpec-${arch}", NuGetSpec) {
		dependsOn nugetCopyTarget(arch)
		String toolset = getSelectedVisualStudioToolChain().toolset
		String bin = "bin"
		String lib = "lib"
		String suffix = ""
		if (arch == 'x64') {
			bin += "64";lib += "64";suffix = "64";
		}
		nuspec = [
			metadata: commoNuspecMetadata + [
				id:          	"Pocoproject.Poco.${toolset}.${arch}",
				title:          "Pocoproject Poco ${toolset} $version ${arch}",
				dependencies: [ { dependency(id: "Pocoproject.OpenSSL.vs120.${arch}", version: "1.1.0") } ]
			],
			files: [
				{ file(src: "$rootDir\\packaging\\Windows\\NuGet\\Pocoproject.Poco.${toolset}.${arch}.targets", 				target: "build\\native") },
				{ file(src: "$rootDir\\${bin}\\Poco*${suffix}.*", 		target: "build\\native\\${bin}", 		exclude: "$rootDir\\bin\\*CppParser*.*") },
				{ file(src: "$rootDir\\${lib}\\Poco*.*",				target: "build\\native\\${lib}", 		exclude: "$rootDir\\bin\\*CppParser*.*") },
				{ file(src: "$rootDir\\${bin}\\Poco*${suffix}d.*", 		target: "build\\native\\${bin}", 		exclude: "$rootDir\\bin\\*CppParser*.*") },
				{ file(src: "$rootDir\\${lib}\\Poco*d.*",				target: "build\\native\\${lib}", 		exclude: "$rootDir\\bin\\*CppParser*.*") },
				{ file(src: "$rootDir\\CppUnit\\include\\**",			target: "build\\native\\inc") },
				{ file(src: "$rootDir\\Foundation\\include\\**",		target: "build\\native\\inc") },
				{ file(src: "$rootDir\\Encodings\\include\\**",			target: "build\\native\\inc") },
				{ file(src: "$rootDir\\Crypto\\include\\**",			target: "build\\native\\inc") },
				{ file(src: "$rootDir\\Data\\include\\**",				target: "build\\native\\inc") },
				{ file(src: "$rootDir\\Data\\MySQL\\include\\**",		target: "build\\native\\inc") },
				{ file(src: "$rootDir\\Data\\ODBC\\include\\**",		target: "build\\native\\inc") },
				{ file(src: "$rootDir\\Data\\SQLite\\include\\**",		target: "build\\native\\inc") },
				{ file(src: "$rootDir\\Data\\PostgreSQL\\include\\**",	target: "build\\native\\inc") },
				{ file(src: "$rootDir\\JSON\\include\\**",				target: "build\\native\\inc") },
				{ file(src: "$rootDir\\MongoDB\\include\\**",			target: "build\\native\\inc") },
				{ file(src: "$rootDir\\Net\\include\\**",				target: "build\\native\\inc") },
				{ file(src: "$rootDir\\NetSSL_OpenSSL\\include\\**",	target: "build\\native\\inc") },
				{ file(src: "$rootDir\\NetSSL_Win\\include\\**",		target: "build\\native\\inc") },
				{ file(src: "$rootDir\\PDF\\include\\**",				target: "build\\native\\inc") },
				{ file(src: "$rootDir\\Util\\include\\**",				target: "build\\native\\inc") },
				{ file(src: "$rootDir\\XML\\include\\**",				target: "build\\native\\inc") },
				{ file(src: "$rootDir\\Zip\\include\\**",				target: "build\\native\\inc") }			
			]
		]
		outputs.file(nuspecFile)
	}
}
def pocoNugetPack(arch) {
	return tasks.create("pocoNugetPack-${arch}", NuGetPack) {
		def Set<Task> pocos = project.getTasksByName('poco', true)
		setDependsOn(pocos)
		destinationDir "$rootDir/packaging/Windows/Nuget"
		dependsOn pocoNugetSpec(arch)
		nuspecFile = project.tasks.findByPath("pocoNugetSpec-$arch").nuspecFile
	}
}

task packaging() {
	if (os.windows) {
		dependsOn pocoNugetPack('x86')
		dependsOn pocoNugetPack('x64')
		dependsOn wix
	}
}
//
//	gradle\bin\gradle Zip:testsuite:check -Ptest=-all
//
def cover(os, Directory, Module) {
	return tasks.create("cover-${Module}", Exec) {
		String PATH = System.getenv("PATH")
		PATH = "$rootDir\\bin;$PATH"
		PATH = "$rootDir\\openssl\\build\\win32\\bin\\release;$PATH"
		PATH = "$rootDir\\openssl\\build\\win32\\bin\\debug;$PATH"
		PATH = "$mysql32Home".replace('/','\\') + "\\lib;$PATH"
		PATH = "$postgres32Home".replace('/','\\') + "\\lib;$PATH"
		environment "Path", "$PATH"
//		println environment.Path

		environment "POCO_BASE", "$rootDir"
//		println "POCO_BASE=" + environment.POCO_BASE

		String CPPUNIT_IGNORE;
		CPPUNIT_IGNORE =  'class CppUnit::TestCaller<class NTPClientTest>.testTimeSync';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class RawSocketTest>.testEchoIPv4';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class RawSocketTest>.testSendToReceiveFromIPv4';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class ICMPClientTest>.testPing';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class ICMPClientTest>.testBigPing';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class HTTPSClientSessionTest>.testProxy';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class HTTPSStreamFactoryTest>.testProxy';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class TCPServerTest>.testReuseSocket';

		//FIXME Those test below should work
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class ProcessTest>.testLaunch';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class ProcessTest>.testLaunchRedirectIn';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class ProcessTest>.testLaunchRedirectOut';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class ProcessTest>.testLaunchEnv';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class ProcessTest>.testLaunchArgs';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class ProcessTest>.testIsRunning';
		CPPUNIT_IGNORE+=', class CppUnit::TestCaller<class ProcessTest>.testIsRunningAllowsForTermination';
			
		environment "CPPUNIT_IGNORE", "\"$CPPUNIT_IGNORE\""
//		println "CPPUNIT_IGNORE=" + environment.CPPUNIT_IGNORE


		def Set<Task> tests = project.getTasksByName("testsuite:${Module}", true)
		setDependsOn(tests)

		workingDir "coverage/${Directory}"
		file(workingDir).mkdirs()

		executable "${OpenCppCoverageHome}/OpenCppCoverage.exe"
		args "-q"
		args "$rootDir/${Directory}/testsuite/guild/exe/${Module}TestSuite/win32/debug/${Module}TestSuite.exe"
		args "--modules", "Poco*d.dll"
		args "--export_type", "cobertura"
		args "--continue_after_cpp_exception"
		args "--"
		args "-all"

		outputs.file(new File(workingDir,"${Module}TestSuite.xml"))
		
		onlyIf(new Spec<Exec>() {
			boolean isSatisfiedBy(Exec task) {
				   return os.windows;
			}
		});
	}
}
def report(os, Directory, Module) {
	return tasks.create("report-${Module}", Exec) {
		dependsOn cover(os, Directory, Module)
		
		executable "${ReportGeneratorHome}/ReportGenerator.exe"
		args "-verbosity:Verbose"
		args "-reports:coverage/${Module}/${Module}TestSuiteCoverage.xml"
		args "-targetdir:coverage/${Module}"
//		args "-sourcedirs:XML/src;XML/include;CppUnit/src;CppUnit/include;Foundation/src;Foundation/include"

		File targetDir = new File("coverage/${Module}")
		inputs.file(new File(targetDir,"${Module}TestSuite.xml"))

		onlyIf(new Spec<Exec>() {
			boolean isSatisfiedBy(Exec task) {
				   return os.windows;
			}
		});
	}
}
task coverage() {
	if (os.windows) {
		def Set<Task> tasksSet = project.getTasksByName('testsuite', true)
		println "task coverage: covered modules"
		println "--------------------------------------"
		tasksSet.each { task -> println task.project.parent.path.replace(':','/').substring(1) }
		println "--------------------------------------"
		tasksSet.each { task -> dependsOn report(os, task.project.parent.path.replace(':','/').substring(1), task.project.parent.name) }
	}
}
/*
task all() {
        FileCollection incs = task.includes;
        incs.each { dir -> fileTree(dir).files.each { file -> inputs.files(file) }};
        inputs.files.each { file -> println file.path }
}
*/
/*
    tasks { t ->
        $.components.main.binaries.each { binary ->
            def stripTask = binary.tasks.taskName("strip")
            t.create(stripTask) {
                dependsOn binary.tasks.link
                doFirst {
                    if (binary.toolChain in Gcc) {
                        ["strip", binary.tasks.link.outputFile].execute().waitForOrKill(1000)
                    }
                }
            }
            binary.tasks.build.dependsOn stripTask
        }
    }
*/




